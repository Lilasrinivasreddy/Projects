# import aiohttp
# import json
# import asyncio
# import time
# import pandas as pd
# from tqdm.asyncio import tqdm
# import uuid
# from datetime import datetime

# url = "https://qverse-api-dev.verizon.com/api/v1.0/qverse/converse"

# headers = {
#   'Authorization': 'AuthBearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1cHR5bzEiLCJwbGF0Zm9ybSI6ImF1dG9iaSIsIlN0YXJ0IFRpbWUiOiIyMDI1LTA4LTA2IDExOjMwOjM5In0.hyp8l43z1OneYYTeEh84Q72VUe4_pB2eOyl0--WgRLM',
#   'Content-Type': 'application/json',
#   "X-Session-Id": "2835b952-9643-46fd-93d5-5db6f9844122"
# }
# user_question = [
#     "What is the trend of customer sentiment over the past 6 months?",
#     "What is the distribution of overall sentiment for postpaid callers ?",
#     "Which regions or locations have the lowest customer sentiment?",
#     "How many calls had a negative sentiment in the first fortnight of March 2025?",
#     "Which primary topics are most associated with supervisor escalations?",
#     "For calls with supervisor escalations, what are the most common L1 call drivers?",
#     "Which combination of L1 call driver and primary intent has the highest call volume, and what is the customer sentiment for these calls?",
#     "What are the most frequent primary intents for calls that involve troubleshoot tickets?",
#     "How do different primary intents impact whether a callback was promised?",
#     "What are the top L1 call drivers contributing to the total call time?"
# ]

# async def fetch(session, request_id, question):
#     chat_user = f"{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}_{uuid.uuid4()}"
#     payload = {
#         "chatid": chat_user,
#         "user_question": question,
#         "domain": "Convoiq",
#         "catalog": "Loyalty",
#         "show_summary": True,
#         "show_visualization": True,
#         "use_report": False,
#         "report_id": 0,
#         "temperature": 0,
#         "llm": "default"
#     }

#     event_rows = []
    
#     try:
#         start_time = time.time()
        
#         async with session.post(url, headers=headers, json=payload) as response:
#             status = response.status
#             prev_event_time = start_time

#             # Asynchronously read the response stream line by line
#             async for line_bytes in response.content:
#                 line = line_bytes.decode('utf-8')
                
#                 if line.strip().startswith("data:"):
#                     try:
#                         current_event_time = time.time()
#                         json_part = line.strip()[5:].strip()
#                         data_obj = json.loads(json_part)
                        
#                         event = data_obj.get("event", "")
#                         data = data_obj.get("data", "")

#                         event_rows.append({
#                             'Request_ID': request_id,
#                             'Chat_User': chat_user,
#                             'Chat_UserQuestion': question,
#                             'Status_Code': status,
#                             # Total_Latency_sec for each event
#                             'Total_Latency_sec': round(current_event_time - start_time, 3),
#                             'Event': event,
#                             'Event_Data': str(data),
#                             # Latency between consecutive events
#                             'Event_Latency_sec': round(current_event_time - prev_event_time, 3),
#                             'Event_Timestamp': datetime.fromtimestamp(current_event_time).isoformat(),
#                             'Error': ''
#                         })
#                         prev_event_time = current_event_time

#                     except Exception as e:
#                         event_rows.append({
#                             'Request_ID': request_id,
#                             'Chat_User': chat_user,
#                             'Chat_UserQuestion': question,
#                             'Status_Code': status,
#                             'Total_Latency_sec': round(time.time() - start_time, 3),
#                             'Event': 'ParseError',
#                             'Event_Data': line,
#                             'Event_Latency_sec': '',
#                             'Event_Timestamp': datetime.now().isoformat(),
#                             'Error': str(e)
#                         })

#     except Exception as e:
#         event_rows.append({
#             'Request_ID': request_id,
#             'Chat_User': chat_user,
#             'Chat_UserQuestion': question,
#             'Status_Code': 'Error',
#             'Total_Latency_sec': '',
#             'Event': 'RequestFailed',
#             'Event_Data': '',
#             'Event_Latency_sec': '',
#             'Event_Timestamp': '',
#             'Error': str(e)
#         })
    
#     return event_rows


# # Main function to run all requests
# async def main():
#     results = []
#     async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=60)) as session:
#         tasks = [fetch(session, i + 1, q) for i, q in enumerate(user_question)]
#         for f in tqdm(asyncio.as_completed(tasks), total=len(tasks), desc="Processing Requests"):
#             result = await f
#             results.extend(result)

#     if results:
#         df = pd.DataFrame(results)
#         df.to_csv('all_event_latencies_2.csv', index=False)
#         print("✅ Saved to all_event_latencies.csv")
#     else:
#         print("⚠️ No results were collected. The DataFrame will not be saved.")

# # Run the script
# if __name__ == "__main__":
#     asyncio.run(main())

import re
import aiohttp
import json
import asyncio
import time
import pandas as pd
from tqdm.asyncio import tqdm
import uuid
from datetime import datetime

# Dev URL
url = "https://qverse-api-dev.verizon.com/api/v1.0/qverse/converse"

#Dev Auth
headers = {
  'Authorization': 'AuthBearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1cHR5bzEiLCJwbGF0Zm9ybSI6ImF1dG9iaSIsIlN0YXJ0IFRpbWUiOiIyMDI1LTA4LTA2IDExOjMwOjM5In0.hyp8l43z1OneYYTeEh84Q72VUe4_pB2eOyl0--WgRLM',
  'Content-Type': 'application/json',
  "X-Session-Id": "2835b952-9643-46fd-93d5-5db6f9844122"
}

# # Prod URL
# url = "https://qverse-api-prod.verizon.com/api/v1.0/qverse/converse"

# # Prod Auth
# headers = {
#   'Authorization': 'AuthBearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1cHR5bzEiLCJwbGF0Zm9ybSI6ImF1dG9iaSIsIlN0YXJ0IFRpbWUiOiIyMDI1LTA4LTA4IDEwOjA3OjMyIn0.eOO2gT-ryamCNnjZgQ_pWNl0fPZmhXqbsmX-QUC_nIs',
#   'Content-Type': 'application/json',
#   "X-Session-Id": "80cd479b-f181-41e0-b83f-110b3d0998e5"
# }

# user_question = [
#     # 'Provide me the customer list that were churned in past 3 months?'
#     # 'Sentiment of the Customers that lead to churn?'
#     # 'provide me the call rep details where the customers were churned'
#     # "What's the overall sentiment breakdown for customers on a postpaid plan?"
#     # 'What are the top performing sales channels based on gross additions or net additions?'

# 'What are the total gross additions, net additions, and churn for last quarter?',
# 'How do gross additions, net additions, and churn vary by sales channel?',
# 'What are the trends in gross additions, net additions, and churn over time (e.g., monthly, quarterly, yearly)?',
# 'What are the top performing sales channels based on gross additions or net additions?',
# 'How do customer segments (e.g., consumer, business) contribute to gross additions and churn?',
# 'What is the breakdown of gross additions by product type (e.g., phone, tablet, FWA)?',
# 'How many customers are porting in or out from specific carriers like AT&T, T-Mobile, or Comcast?',
# 'What is the total number of phone upgrades?',
# 'What is the total number of new accounts, and how does this break down by single-phone vs. multi-phone accounts?',
# 'How have our monthly gross and net additions trended over the last fiscal year?',
# 'What are the quarterly patterns in customer churn over the past three years?',
# 'Are there any noticeable seasonal trends in our yearly gross customer acquisitions?',
# 'What has been the compound monthly growth rate for net additions?',
# 'How does the trend in gross additions compare with the trend in churn on a quarterly basis?',
# 'Is there a correlation between the rate of gross additions in one period and the churn rate in a subsequent period?',
# 'How has the ratio of gross additions to churn evolved month-over-month?',
# 'What was the exact number of gross new customers we acquired in the last quarter?',
# 'What was the total number of customers who churned during the last quarter?',
# 'What was the final net addition figure for the previous quarter?',
# 'How do the gross additions from the last quarter compare to the same quarter last year?',
# 'How many gross additions were for phones in the last quarter?',
# 'What was the total number of new tablet activations?',
# 'How many Fixed Wireless Access (FWA) units were added recently?',
# 'Which product type accounted for the highest number of gross additions last month?',
# 'What percentage of our total gross additions did each product type (phone, tablet, FWA) represent in the last fiscal year?'


# # 'What is the trend of customer sentiment over the past 6 months?',
# # 'What is the distribution of overall sentiment for postpaid callers?',
# # 'Which regions or locations have the lowest customer sentiment?',
# # 'How many calls had a negative sentiment in the first fortnight of March 2025?',
# # 'Which top 5 primary topics are most associated with supervisor escalations?',
# # 'For calls with supervisor escalations, what are the most common L1 call drivers?',
# # 'Which top 2 combination of L2 call driver and primary intent has the highest call volume, and what is the customer sentiment for these calls?',
# # 'What are the most frequent primary intents for calls that involve troubleshoot tickets?',
# # 'How do different primary intents impact whether a callback was promised?',
# # 'What are the top L1 call drivers contributing to the total call time?',
# # 'How does the call disconnection rate vary across different event hours?',
# # 'Which top 5 agents have the highest negative sentiment scores?',
# # 'Which top 5 agents show the most improvement in customer sentiment scores over time?',
# # 'What is the sentiment score for calls that required multiple transfers versus those with no transfers?',
# # 'How does sentiment correlate with call back promised?',
# # 'Are there specific call drivers associated with lower or higher sentiment scores ?',
# # 'What are the top 5 key primary topics discussed in calls with negative sentiment compared to positive sentiment calls?',
# # 'Which top 5 primary call topics are most associated with neutral sentiment?',
# # 'Can you show the distribution of overall customer sentiment by L1 call driver?',
# # 'How many calls with positive customent sentiment in the first half but overall sentiment is neutral',
# # 'What is the trend of customer sentiment over the past 8 months?',
# # 'What is the distribution of overall sentiment for prepaid callers ?',
# # 'Which regions or locations have the highest customer sentiment?',
# # 'How many calls had a negative sentiment in the first fortnight of April 2025?',
# # 'Which top 3 primary topics are most associated with supervisor escalations?',
# # 'What are the most frequent primary intents for calls that involve troubleshoot tickets?',
# # 'How do different primary intents impact whether a callback was promised?',
# # 'What are the top L2 call drivers contributing to the total call time?',
# # 'How does the call disconnection rate vary across different event hours?',
# # 'Which top 5 agents have the highest positive sentiment scores?',
# # 'Can you show the distribution of overall customer sentiment by L2 call driver?',
# # 'How many calls with negative customent sentiment in the first half but overall sentiment is neutral',
# # 'What is the trend of customer sentiment over the past 4 months?',
# # 'What is the distribution of overall sentiment for postpaid callers ?',
# # 'Which regions or locations have the lowest customer sentiment?',
# # 'Which top 2 combination of L1 call driver and primary intent has the highest call volume, and what is the customer sentiment for these calls?',
# # 'What is the trend of customer sentiment over the past 2 months?',
# # 'What is the distribution of negative sentiment for postpaid callers?',
# # 'What is the distribution of positive sentiment for postpaid callers?',
# # 'What is the distribution of positive sentiment for prepaid callers?',
# ]


user_question = [
    # Overall Call Center Performance
    # "Is there a correlation between call duration and customer emotion lift?"
    # "What is the total number of calls handled by the call center?",
    # "What is the average call duration?",
    # "How many calls were abandoned, and what is the average time to abandonment?",
    # "What is the call answer rate?",
    # "What is the breakdown of total calls handled by each call queue for the last 30 days?",
    # "How does the call volume of this month compare to the same month last year?",
    # "What was the hour with the highest call volume yesterday?",
    # "Can you compare the call volume for this week against the weekly average for the last quarter?",
    # "What is the trend of total calls handled over the last six months?",
    # "What is the average call duration for the 'Technical Support' queue versus the 'Billing' queue?",
    # "Which agent team has the longest average call duration for the current month?",
    # "How does the average call duration for inbound calls compare to outbound calls?",
    # "What is the trend of the average call duration over the past 12 months?",
    # "Is there a correlation between average call duration and customer satisfaction scores?"

    # # Customer Disconnect Analysis
    # "What are the primary reasons for customer disconnects?",
    # "How many customers called before disconnecting their services?",
    # "What is the save rate for customers who were offered retention strategies?",
    # "What is the distribution of disconnects by device type (e.g., Smartphone, Tablet)?",
    # "Is there a difference in disconnect rates between digital and non-digital channels?",

    # # Agent Performance and Effectiveness
    # "What is the average customer emotion lift during calls?",
    # "How often do agents use the \"Agent Tool Box\" to retain customers?",
    # "What are the most common accepted and rejected offers by customers?",
    # "What is the quality of agent attempts to save customers?",
    # "How does agent performance vary across different call centers or agent groups?",

    # # # Customer Sentiment and Intent
    # "What is the overall sentiment of customer calls (Positive, Negative, Neutral)?",
    # "What are the primary and secondary intents of customer calls?",
    # "How does customer sentiment change throughout a call (first half vs. second half)?",
    # "What are the most common customer pain points or upset reasons?",

    # # # Offer and Effort Analysis
    # "What is the acceptance rate and rejection rate of offers?",
    # "What types of offers are most effective in retaining customers?",
    # "How many efforts are typically used by agents per call?",
    # "What are the combinations of offers and efforts that lead to the highest save rates?",

    # # # Time-based Analysis
    # "How do call volumes, disconnects, and save rates trend over time (daily, weekly, monthly, quarterly, yearly)?",
    # "Are there any specific times or days when certain issues or sentiments are more prevalent?",

    # "How many calls were abandoned, and what is the average time to abandonment?",
    # "How many calls were abandoned, and what is the average time to abandonment?",
    # "How many calls were abandoned, and what is the average time to abandonment?",
    # "How many calls were abandoned, and what is the average time to abandonment?",
    # "How many calls were abandoned, and what is the average time to abandonment?"

    "How many customers (lines) disconnected last month?",
    "What are the top 10 reasons for disconnection by line count?",
    "How many lines were part of a full account disconnect vs. a single-line disconnect?",
    "Which device types are most commonly associated with disconnections?",
    "What is the trend of line disconnects over the past 6 months?",
    "How many customer lines on a MyPlan offering disconnected last quarter?",
    "What percentage of disconnects are processed through digital channels?"
]

run_id = uuid.uuid4()

async def fetch(session, request_id, question):
    chat_user = f"{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}_{run_id}"
    payload = {
        "chatid": chat_user,
        "user_question": question,
        "domain": "Convoiq",
        "catalog": "Loyalty",
        "show_summary": True,
        "use_lsp": True,
        "show_visualization": True,
        "use_report": False,
        "report_id": 0,
        "temperature": 0,
        "llm": "default"
    }

    event_rows = []
    
    try:
        start_time = time.time()
        
        async with session.post(url, headers=headers, json=payload) as response:
            status = response.status
            prev_event_time = start_time
            transaction_id = response.headers.get("X-Transaction-Id", "N/A")
            async for line_bytes in response.content:
                line = line_bytes.decode('utf-8')
                
                if line.strip().startswith("data:"):
                    try:
                        current_event_time = time.time()
                        json_part = line.strip()[5:].strip()
                        data_obj = json.loads(json_part)
                        
                        event = data_obj.get("event", "")
                        data = data_obj.get("data", "")

                        event_rows.append({
                            'Request_ID': request_id,
                            'Transaction_ID': transaction_id,
                            'Chat_User': chat_user,
                            'Chat_UserQuestion': question,
                            'Status_Code': status,
                            'Total_Latency_sec': round(current_event_time - start_time, 3),
                            'Event': event,
                            'Event_Data': str(data),
                            'Event_Latency_sec': round(current_event_time - prev_event_time, 3),
                            'Event_Timestamp': datetime.fromtimestamp(current_event_time).isoformat(),
                            'Error': ''
                        })
                        prev_event_time = current_event_time

                    except Exception as e:
                        event_rows.append({
                            'Request_ID': request_id,
                            'Transaction_ID': transaction_id,
                            'Chat_User': chat_user,
                            'Chat_UserQuestion': question,
                            'Status_Code': status,
                            'Total_Latency_sec': round(time.time() - start_time, 3),
                            'Event': 'ParseError',
                            'Event_Data': line,
                            'Event_Latency_sec': '',
                            'Event_Timestamp': datetime.now().isoformat(),
                            'Error': str(e)
                        })

    except Exception as e:
        event_rows.append({
            'Request_ID': request_id,
            'Transaction_ID': 'N/A',
            'Chat_User': chat_user,
            'Chat_UserQuestion': question,
            'Status_Code': 'Error',
            'Total_Latency_sec': '',
            'Event': 'RequestFailed',
            'Event_Data': '',
            'Event_Latency_sec': '',
            'Event_Timestamp': '',
            'Error': str(e)
        })
    
    return event_rows

# def create_dataframe_and_save_csv(results, process_id):
#     if results:
#         for item in results:
#             if 'Event_Data' in item and isinstance(item['Event_Data'], str):
#                 item['Event_Data'] = re.sub(r'\s+', ' ', item['Event_Data']).strip()
#         df = pd.DataFrame(results)
#         print(df['Event'])
#         # data = df.loc[df['Event']=='records', 'Event_Data']
#         # print(data)
#         # df_sorted = df.sort_values(by='Request_ID')
#         # # Use a unique filename for each process
#         # filename = f'C:/Users/guptyo1/Result/Batch_30_Dev_Single_process_{process_id}.csv'
#         # df_sorted.to_csv(filename, index=False)
#         # print(f"✅ Saved to {filename}")
#     else:
#         print("⚠️ No results were collected. The DataFrame will not be saved.")

def create_dataframe_and_save_csv(results, process_id):
    if results:
        for item in results:
            if 'Event_Data' in item and isinstance(item['Event_Data'], str):
                item['Event_Data'] = re.sub(r'\s+', ' ', item['Event_Data']).strip()
        df = pd.DataFrame(results)
        df_sorted = df.sort_values(by=['Request_ID', 'Event_Timestamp'])
        # print(df['Event'])
        # Use a unique filename for each process
        # filename = f'C:/Users/guptyo1/Result_Lsp/19_09_25/Lsp_19_09_25_{process_id}.csv'
        filename = f'C:/Users/guptyo1/Result_Lsp/19_09_25/Lsp_19_09_25_golden_question.csv'
        df_sorted.to_csv(filename, index=False)
        print(f"✅ Saved to {filename}")
    else:
        print("⚠️ No results were collected. The DataFrame will not be saved.")

async def main(process_id):
    results = []
    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=60)) as session:
        tasks = [fetch(session, i + 1, q) for i, q in enumerate(user_question)]
        for f in tqdm(asyncio.as_completed(tasks), total=len(tasks), desc=f"Processing Requests (Process {process_id})"):
            result = await f
            results.extend(result)
    create_dataframe_and_save_csv(results, process_id)

def run_script_instance(process_id):
    asyncio.run(main(process_id))

if __name__ == "__main__":
    asyncio.run(main(0)) # This runs a single instance if executed directly.


