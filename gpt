environment = config.get('environment', 'env').capitalize()



def send_email_alert(
    self, vsad_name: str = '', message: str = None, subject: str = None,
    df_val=pd.DataFrame(), receipents_email_group: list = None
):
    self.logger.info('-------------------------------------------------------------------------')
    self.logger.info('Email Initiated')
    self.logger.info('-------------------------------------------------------------------------')

    try:
        # Drop unnecessary columns before sending email
        df_val = df_val.drop(['update_made_ts', 'insert_made_ts'], axis=1)

        # Fetch environment
        environment = config.get('environment', 'env').capitalize()

        # Dynamically construct subject line
        subject = (
            subject if subject not in config.EMPTY_STR_LIST 
            else f"LensX|{environment}|Source Check Availability|DQ2.0|{self.data_src}|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )

        # Default message if not provided
        message = (
            message if message not in config.EMPTY_STR_LIST 
            else f"Please find the below Source Check Summary for the current run."
        )

        # Get email recipients
        receipents_email_addr_list = receipents_email_group or config.SLA_WATCHER_DEFAULT_MAIL_GROUP

        self.logger.info(f"Receipents Email Group: {receipents_email_addr_list}")

        # Send email
        self.email.send_common_message(
            email_template_filepath=config.common_email_template,
            mail_subject=subject,
            message=message,
            df_val=df_val,
            receipents_email_id=receipents_email_addr_list
        )

        self.logger.info('Email Sent Successfully')
    except Exception as e:
        self.logger.error(f"Error occurred while sending email: {e}")






def main(self, data_src, profile_type):
    try:
        count_results = []
        self.data_src = data_src
        self.df_unique = self.df.drop_duplicates(subset=["PROJECT_NAME", "DATABASE_NAME", "TABLE_NAME"])
        self.input_rows = self.df_unique.to_dict('records')
        self.logger.info(f"Input Rows :: {len(self.input_rows)}")

        # Run source check queries using threading
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.MAX_THREADS) as executor:
            result_futures = executor.map(self.src_chk_run_query, self.input_rows)
            for future in result_futures:
                count_results.append(future)

        if count_results:
            count_results_df = pd.DataFrame(count_results)
            count_results_df['retry_count'] = 0
            count_results_df['profile_type'] = profile_type
            count_results_df['server_name'] = np.nan
            count_results_df['run_status'] = 'Ready'
            count_results_df['run_dt'] = np.datetime64(datetime.now(ZoneInfo("US/Eastern")).date())
            count_results_df['update_made_ts'] = np.datetime64(datetime.now(ZoneInfo("US/Eastern")))
            count_results_df['insert_made_ts'] = np.datetime64(datetime.now(ZoneInfo("US/Eastern")))
            self.logger.info(f"Count Results Length: {len(count_results_df)}")

            # Send summary email
            self.send_email_alert(
                df_val=count_results_df,
                receipents_email_group=config.SLA_WATCHER_DEFAULT_MAIL_GROUP,
                subject=f"LensX|{config.get('environment', 'env').capitalize()}|Source Check Summary|DQ2.0|{data_src}|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
    except Exception as e:
        self.logger.error(f"Error in main method of Source Check Availability Process. Error: {e}")
        raise Exception(f"Error in main method of Source Check Availability Process. Error: {e}")


def construct_email_subject(self, profiling_stage: str):
    environment = config.get('environment', 'env').capitalize()
    return f"LensX|{environment}|{profiling_stage}|DQ2.0|{self.data_src}|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"