def compare_historical_latest_dimensions(self, df_tbl_hist_rec, df_tbl_latest_rec: pd.DataFrame, comparison_type="WEEKDAYS", isHourly="N"):
    self.logger.info('------------------------------------------------------------------')

    # Ensure all column names are lowercase
    df_tbl_hist_rec = df_tbl_hist_rec.rename(columns={col: str(col).lower() for col in df_tbl_hist_rec.columns.tolist()})
    df_tbl_latest_rec = df_tbl_latest_rec.rename(columns={col: str(col).lower() for col in df_tbl_latest_rec.columns.tolist()})

    # Ensure column types are consistent before merging
    for col in df_tbl_hist_rec.columns.intersection(df_tbl_latest_rec.columns):
        if df_tbl_hist_rec[col].dtype != df_tbl_latest_rec[col].dtype:
            self.logger.warning(f"Column type mismatch detected in {col}: "
                                f"Historical={df_tbl_hist_rec[col].dtype}, Latest={df_tbl_latest_rec[col].dtype}")

            # Convert float to string if necessary
            if df_tbl_hist_rec[col].dtype == 'float64' and df_tbl_latest_rec[col].dtype == 'object':
                df_tbl_latest_rec[col] = df_tbl_latest_rec[col].astype(float)
            elif df_tbl_hist_rec[col].dtype == 'object' and df_tbl_latest_rec[col].dtype == 'float64':
                df_tbl_hist_rec[col] = df_tbl_hist_rec[col].astype(float)

    # Merge DataFrames after fixing type mismatches
    join_list = ['prfl_id', 'feature_name', 'grouped_columns', 'weekday']
    if comparison_type == 'DTRAN_MONTHLY':
        join_list.remove('weekday')

    df_merge_rec = pd.merge(
        df_tbl_hist_rec,
        df_tbl_latest_rec,
        on=join_list,
        how='right'
    )

    self.logger.info(f'Length of the Merged Records : {len(df_merge_rec)}')
    return df_merge_rec
============
df_historical = self.get_historical_details(
    run_date=start_date,
    prfl_id_list=prfl_id_list,
    comparison_type=comparisonType
)

if df_historical is None:
    self.logger.error("Historical data is None, skipping comparison.")
    return None  # Prevents further execution

df_latest = self.profile_engine(
    df_rules=df_mtd,
    param_to_replace=val_replace_params,
)

if df_latest is None:
    self.logger.error("Latest data is None, skipping further processing.")
    return None  # Prevents further execution
===========
df_end_result = self.run_metrics_engine(
    df_mtd=df_mtd,
    start_date=start_date,
    end_date=end_date,
    val_replace_params=replace_params_for_rules
)

if df_end_result is None or len(df_end_result) == 0:
    self.logger.error("No valid records found for Custom Metrics. Exiting...")
    return  # Prevents further execution
